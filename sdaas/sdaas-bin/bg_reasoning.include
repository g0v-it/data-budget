if [ ! -z ${__module_bg_reasoning+x} ]; then return ; else __module_bg_reasoning=1 ; fi

SD_REQUIRES_VAR SD_HOSTNAME
SD_REQUIRES_CMD rapper gzip mktemp realpath chmod SD_REGISTER_SERVICE SD_FETCH_SERVICE SD_UNREGISTER_SERVICE


_SD_REP=http://localhost:9999/blazegraph
_SD_ARCHETYPES=${_SD_CONFIG_DIRS:="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/archetypes"}

function _SD_ENSURE_BG_ENDPOINT_EXITS {
	if [ -z "$SD_LOCAL_BG_ENDPOINT" ]; then
		SD_LOCAL_BG_ENDPOINT="http://localhost:$(ps -ef | grep blazegraph | grep -oP "jetty.port=\d+" | grep -oP "\d+")/blazegraph"
		curl -s -f  "$SD_LOCAL_BG_ENDPOINT/status" > /dev/null 2>&1 || SD_FATAL_ERROR "No running blazegraph instance."
	fi
}



# @description create a reasoner based on blazegraph extensions
# each reasoner has an archetype (ie. specific features pre configured):
#  . **rdfs** implements an rdfs triplestore reasoner
#  . **geo** is able extends sparql triplestore  with [geospatial search](https://wiki.blazegraph.com/wiki/index.php/GeoSpatial)
#  . **lexical** add lucene  [textual indices](https://wiki.blazegraph.com/wiki/index.php/FullTextSearch) to triplestore
#  . **kbplus** is a quadstore with both textual and geospatial features installed
# beside standard reasoners there is also a default sparql 1.1. quadstore with name **kb**.
# knowledge base archetipes are in the scripts/archetipes directory
#
# @arg $1 a reasoner archetype
#
function SD_CREATE_REASONER {
	local archetype="$1"
	local namespace="${2:-"${archetype}-${RANDOM}"}"
		
	test -f  "$_SD_ARCHETYPES/${archetype}.txt"  || SD_FATAL_ERROR "Invalid reasoner archetype ($archetype)."
	_SD_ENSURE_BG_ENDPOINT_EXITS

	SD_DEBUG_INFO "Creating reasoner namespace $namespace using @$_SD_ARCHETYPES/${archetype}.txt"
	local description=$(cat $_SD_ARCHETYPES/${archetype}.txt | sed "s/%namespace/$namespace/g")
	SD_DEBUG_INFO "$(curl -s -X POST --data-binary "$description" --header 'Content-Type:text/plain' "$SD_LOCAL_BG_ENDPOINT/namespace")"
	
	reasonerId=$(SD_REGISTER_SERVICE "$SD_LOCAL_BG_ENDPOINT|$namespace|$archetype" $namespace)
	echo "$reasonerId"
}


function SD_DESTROY_REASONER {
	local reasonerId="$1"
	
	local endpoint namespace archetype
	IFS='|' read  endpoint namespace archetype <<< $(SD_FETCH_SERVICE "$reasonerId")
	
	SD_DEBUG_INFO "Destroying reasoner ${reasonerId}"
	SD_DEBUG_INFO "$(curl -s -X DELETE "$endpoint/namespace/$namespace")"
	SD_UNREGISTER_SERVICE "$reasonerId"
}



# @description a sparql compliant interface to a reasoner
#
# @example
#   SD_REASONER_QUERY rdfs text/csv "select * where {?s ?p ?o} LIMIT 1"
#   SD_REASONER_QUERY rdfs text/csv "@path/to/input_file_with_query"
#
# @arg $1 the reasoner reference
# @arg $2 mime type for acceppted result (i.e. text/csv or text/turtle)
# @arg $3 a string with a valid sparql query statement (with extension) or a filename prefixed by the  @ character
# @arg $4 an optional writable file were to save debugging info (if debugging enabled)
#
# @exitcode 0  If successfull.
# @exitcode >0 On failure
function SD_REASONER_QUERY {
	local reasonerId="$1"
	local accept="$2"
	local query="$3"
	local traceFile=${4:-$(SD_MK_DEBUG_TMP_FILE sparql_query_trace)}

	local endpoint namespace archetype
	IFS='|' read  endpoint namespace archetype <<< $(SD_FETCH_SERVICE "$reasonerId")

	SD_DEBUG_INFO  "SD_REASONER_QUERY ${endpoint}-${namespace}-${archetype} '$accept' '${query:0:40}...'" 
	curl -X POST \
		--silent \
		--data-binary "$query" \
		--header 'Content-Type: application/sparql-query' \
		--header "Accept: $accept" \
		--trace-ascii "$traceFile" \
		-f "${endpoint}/namespace/${namespace}/sparql"  || SD_FATAL_ERROR "SD_REASONER_QUERY error, see $traceFile"
	if [ $SD_DEBUG -eq 0 ]; then  rm -f "$traceFile"  ; fi
}


function SD_REASONER_UPDATE {
	local reasonerId="$1"
	local data="$2"
	local traceFile="${3:-$(SD_MK_DEBUG_TMP_FILE sparql_query_trace)}"
	
	local endpoint namespace archetype
	IFS='|' read  endpoint namespace archetype <<< $(SD_FETCH_SERVICE "$reasonerId")

	SD_DEBUG_INFO  "SD_REASONER_UPDATE ${endpoint}-${namespace}-${archetype} '${data:0:40}...'"
	SD_DEBUG_INFO "$(curl -X POST \
		--silent \
		--data-binary "$data" \
		--header 'Content-Type: application/sparql-update' \
		--trace-ascii "$traceFile" \
		-f "${endpoint}/namespace/${namespace}/sparql")" || SD_FATAL_ERROR "Unable to update, see $traceFile"
	if [ $SD_DEBUG -eq 0 ]; then  rm -f "$traceFile"  ; fi
}


# see https://wiki.blazegraph.com/wiki/index.php/Bulk_Data_Load
function SD_REASONER_LOAD {
	local reasonerId="$1"
	local inputFile="$2"
	local format="${3:-guess}"
	local graphName="${4:-'urn:default:graph'}"
	
	local endpoint namespace archetype
	IFS='|' read  endpoint namespace archetype <<< $(SD_FETCH_SERVICE "$reasonerId")
	
	mkdir -m 777 -p "$SD_CACHE/blzg" || SD_FATAL_ERROR "Unable to create dataloader dir"
	
	local inputStream fileUri
	if [ "$2" = '-' ]; then 
		fileUri="file://${SD_HOSTNAME}/dev/stdin" 
		inputStream=cat
	else 
		fileUri="file://${SD_HOSTNAME}$(realpath "$inputFile")"
		fileUri=${fileUri// /%20}
		inputStream="cat $inputFile"
	fi
	
	local tempFile=$(mktemp --tmpdir="$SD_CACHE/blzg" payload-XXXXXXXXXX.nt)
	$inputStream | rapper -q -i "$format" -o ntriples - "$fileUri" > "$tempFile" || SD_FATAL_ERROR "SD_REASONER_LOAD Error in rapper -i '$format' '$inputFile' '$graphName' > into $tempFile"
	gzip "$tempFile"  || SD_FATAL_ERROR "Error zipping $tempFile"
	chmod +rw "${tempFile}.gz" || SD_FATAL_ERROR "Unable make ${tempFile}.gz readable and wridable to reasoner service"

	local properties	
	read -r -d '' properties <<-EOT	
		quiet=true
		verbose=0
		closure=false
		durableQueues=true
		defaultGraph=$graphName
		com.bigdata.rdf.store.DataLoader.flush=false
		com.bigdata.rdf.store.DataLoader.bufferCapacity=100000
		com.bigdata.rdf.store.DataLoader.queueCapacity=10
		namespace=$namespace
		format=N-Triples
		fileOrDirs=$(realpath ${tempFile}.gz)
		propertyFile=/RWStore.properties
	EOT
	SD_LOG "Loading reasoner from ${inputFile}..."
	SD_DEBUG_INFO "curl -f --silent -X POST --data-binary '$properties' --header 'Content-Type:text/plain' '$endpoint/dataloader'"
	SD_DEBUG_INFO "$(curl -f --silent -X POST --data-binary "$properties" --header 'Content-Type:text/plain' "$endpoint/dataloader")" || SD_FATAL_ERROR "Error calling dataloader api"	
	test -f "${tempFile}.gz.good" || SD_FATAL_ERROR "Dataloder service failed loading ${tempFile}.gz"	

	if [ $SD_DEBUG -eq 0 ]; then  rm -f "${tempFile}.gz.good" ; fi
}
